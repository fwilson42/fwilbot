# Stubs for configparser (Python 3.5)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, List
from typing import MutableMapping
from collections import OrderedDict as _default_dict, ChainMap as _ChainMap

DEFAULTSECT = ...  # type: Any
MAX_INTERPOLATION_DEPTH = ...  # type: Any

class Error(Exception):
    message = ...  # type: Any
    def __init__(self, msg=''): ...

class NoSectionError(Error):
    section = ...  # type: Any
    args = ...  # type: Any
    def __init__(self, section): ...

class DuplicateSectionError(Error):
    section = ...  # type: Any
    source = ...  # type: Any
    lineno = ...  # type: Any
    args = ...  # type: Any
    def __init__(self, section, source=None, lineno=None): ...

class DuplicateOptionError(Error):
    section = ...  # type: Any
    option = ...  # type: Any
    source = ...  # type: Any
    lineno = ...  # type: Any
    args = ...  # type: Any
    def __init__(self, section, option, source=None, lineno=None): ...

class NoOptionError(Error):
    option = ...  # type: Any
    section = ...  # type: Any
    args = ...  # type: Any
    def __init__(self, option, section): ...

class InterpolationError(Error):
    option = ...  # type: Any
    section = ...  # type: Any
    args = ...  # type: Any
    def __init__(self, option, section, msg): ...

class InterpolationMissingOptionError(InterpolationError):
    reference = ...  # type: Any
    args = ...  # type: Any
    def __init__(self, option, section, rawval, reference): ...

class InterpolationSyntaxError(InterpolationError): ...

class InterpolationDepthError(InterpolationError):
    args = ...  # type: Any
    def __init__(self, option, section, rawval): ...

class ParsingError(Error):
    source = ...  # type: Any
    errors = ...  # type: Any
    args = ...  # type: Any
    def __init__(self, source=None, filename=None): ...
    @property
    def filename(self): ...
    @filename.setter
    def filename(self, value): ...
    def append(self, lineno, line): ...

class MissingSectionHeaderError(ParsingError):
    source = ...  # type: Any
    lineno = ...  # type: Any
    line = ...  # type: Any
    args = ...  # type: Any
    def __init__(self, filename, lineno, line): ...

class Interpolation:
    def before_get(self, parser, section, option, value, defaults): ...
    def before_set(self, parser, section, option, value): ...
    def before_read(self, parser, section, option, value): ...
    def before_write(self, parser, section, option, value): ...

class BasicInterpolation(Interpolation):
    def before_get(self, parser, section, option, value, defaults): ...
    def before_set(self, parser, section, option, value): ...

class ExtendedInterpolation(Interpolation):
    def before_get(self, parser, section, option, value, defaults): ...
    def before_set(self, parser, section, option, value): ...

class LegacyInterpolation(Interpolation):
    def before_get(self, parser, section, option, value, vars): ...
    def before_set(self, parser, section, option, value): ...

class RawConfigParser(MutableMapping):
    SECTCRE = ...  # type: Any
    OPTCRE = ...  # type: Any
    OPTCRE_NV = ...  # type: Any
    NONSPACECRE = ...  # type: Any
    BOOLEAN_STATES = ...  # type: Any
    default_section = ...  # type: Any
    def __init__(self, defaults=None, dict_type=..., allow_no_value=False, *, delimiters=..., comment_prefixes=..., inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section=..., interpolation=..., converters=...) -> None: ...
    def defaults(self): ...
    def sections(self) -> List[str]: ...
    def add_section(self, section: str) -> None: ...
    def has_section(self, section) -> bool: ...
    def options(self, section) -> List[str]: ...
    def read(self, filenames, encoding=None): ...
    def read_file(self, f, source=None) -> None: ...
    def read_string(self, string, source='') -> str: ...
    def read_dict(self, dictionary, source=''): ...
    def readfp(self, fp, filename=None): ...
    def get(self, section, option, *, raw=False, vars=None, fallback=...): ...
    def getint(self, section: str, option: str, *, raw=False, vars=None, fallback=..., **kwargs) -> int: ...
    def getfloat(self, section: str, option: str, *, raw=False, vars=None, fallback=..., **kwargs): ...
    def getboolean(self, section: str, option: str, *, raw=False, vars=None, fallback=..., **kwargs) -> bool: ...
    def items(self, section=..., raw=False, vars=None): ...
    def popitem(self): ...
    def optionxform(self, optionstr): ...
    def has_option(self, section, option) -> bool: ...
    def set(self, section, option, value=None): ...
    def write(self, fp, space_around_delimiters=True) -> None: ...
    def remove_option(self, section, option): ...
    def remove_section(self, section): ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value): ...
    def __delitem__(self, key): ...
    def __contains__(self, key): ...
    def __len__(self): ...
    def __iter__(self): ...
    @property
    def converters(self): ...

class ConfigParser(RawConfigParser):
    def set(self, section, option, value=None): ...
    def add_section(self, section: str) -> None: ...

class SafeConfigParser(ConfigParser):
    def __init__(self, *args, **kwargs): ...

class SectionProxy(MutableMapping):
    def __init__(self, parser, name): ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value): ...
    def __delitem__(self, key): ...
    def __contains__(self, key): ...
    def __len__(self): ...
    def __iter__(self): ...
    @property
    def parser(self): ...
    @property
    def name(self): ...
    def get(self, option, fallback=None, *, raw=False, vars=None, _impl=None, **kwargs): ...

class ConverterMapping(MutableMapping):
    GETTERCRE = ...  # type: Any
    def __init__(self, parser): ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value): ...
    def __delitem__(self, key): ...
    def __iter__(self): ...
    def __len__(self): ...
